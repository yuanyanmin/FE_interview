BFC

块级格式化上下文，形成一个独立的盒子，盒子内部的样式互相影响，不受与外部的样式的影响。

如何产生：

1. overflow 不为 visible
2. display 为 inline-block、flex、table、grid
3. position 为 absolute、fixed
4. html
5. float 不为 none

作用：

解决高度塌陷
margin-重叠
清除浮动
两栏布局

-----------------------------------------------------------------------------------------

水平垂直居中

1. position: absolute; left: 50%;  top: 50%;  margin-left: -50px;  margin-top: -50px;
2. position: absolute; transform:translate(-50%, -50%);
3. display: flex; justify-content: center; align-item: center;
4. position: absolute;  left: 0; right: 0; top: 0; bottom: 0; margin: auto;

-----------------------------------------------------------------------------------------

flex

弹性布局

定义轴线：flex-direction: cloumn | row | row-reverse | column-reverse
定义换行：flex-wrap: no-wrap; wrap | warp-reverse;
定义对齐方式（主轴：justify-content: center; space-around; space-between; flex-start； flex-end;
垂直方向对齐方向（交叉轴）：algin-items：center | flex-start | flex-end | baseline | stretch


项目的属性：

定义放大：flex-grow
定义缩小：flex-shrink
定义本来大小: flex-basis

flex：flex-grow flex-shrink flex-basis( 0 1 auto)

flex: 1 （1 1 0）

flex: auto （1 1 auto）

flex: none （0 0 auto）

-----------------------------------------------------------------------------------------

双飞翼布局与圣杯布局

略

-----------------------------------------------------------------------------------------

scope

data-v[hash:8]

/deep/ 是父亲的 data-v[hash8]

-----------------------------------------------------------------------------------------

事件循环机制

js是单线程，执行的时候从上往下，先执行同步代码，在执行异步任务，异步任务又分为宏任务和微任务，从上到下执行的时候遇到了同步代码就执行，遇到异步任务，则判断是宏任务还是微任务。若为宏任务则加入宏任务队列中，若是微任务则加入微任务队列中。等执行完同步代码后，在执行微任务列表的事件，在执行宏任务队列的事件。

宏任务有 setTimeouot setInterval
微任务有 promise.then

-----------------------------------------------------------------------------------------

深拷贝

json.parse(json.stringfy(obj))  // 弊端是 对于 函数、map、set等类型会丢失 

递归拷贝

js 新增的方法 structuredclone

-----------------------------------------------------------------------------------------

闭包

就是一个函数有权访问另一个函数的作用域。通常是函数嵌套函数，里面函数可以获取到外层函数的变量，

好处是：延长变量的声明周期、创建私有变量

缺点：如果不能及时的清除，可能会造成内存泄漏

解决方法是：手动解除变量的引用


-----------------------------------------------------------------------------------------

数组遍历方式

forEach、map、for、while、reduce

-----------------------------------------------------------------------------------------

axios

axios 请求接口

axios.interceptors.request.use()
axios.interceptors.response.use()

-----------------------------------------------------------------------------------------

跨域

JSONP：使用script标签，callback=fn()，定义一个同名函数，进行调用。缺点：get.
CROS：后端配置一些请求头
Nginx代理

-----------------------------------------------------------------------------------------

垃圾回收机制

回收算法：垃圾回收器按照固定的时间间隔，周期性的寻找那些不在使用的变量，然后清除释放内存。

标记清除法：先对所有的变量都进行打标记，在代码执行结束后，对使用的变量取消标记，在清除节点，然后把有标记的都清除

标记整理法：基于上诉清除后，对内存碎片进行整理。

引用清除法：变量使用则+1，清除则-1，最后将所有为0的清除，问题：循环引用

目前浏览器大都使用的是标记清除法

造成内存泄漏额原因：

1. 全局变量太多
2. console.log
3. 闭包
4. 定时器未清空

-----------------------------------------------------------------------------------------

输入URL发生了什么

输入URL后，判断有没有缓存，若没有缓存，
1. DNS 查找IP
2. 三次握手
3. 发起请求
4. 获取到请求响应
6. 拿到响应数据后进行渲染
7. 生成DOM树 和 CSSOM树
8. 根据响应的规则，将DOM树和CSSOM树生成Render树
9. 执行js
10. 重绘和回流 根据节点的位置 大小等进行绘制
11. 关闭连接（四次挥手）


重绘和回流：

重绘：修改样式，例如背景色、字体颜色等
回流（重排）：影响当前位置布局，例如更改宽度等

如何避免回流：

改变样式的属性合成一次完成

不使用table布局

防抖和节流

-----------------------------------------------------------------------------------------

浏览器缓存策略

协商缓存和强缓存

强缓存：资源没有过期，则直接使用读取 200
协商缓存：资源过期了，需要向后端发请求确认该资源是否还能使用，若能使用则 304，不能则更新资源 200

expire: 日期
cache-control: max-age: 3600 (高)

第一次请求会返回

Etag：编号
Last-Modified: 时间

协商缓存发请求的时候

If-Modified-Since：修改时间
If-None-Match：编号（高）

-----------------------------------------------------------------------------------------

数组可以改变原数组的方法

push、pop、shift、unshift、reverse、sort、splice

-----------------------------------------------------------------------------------------

http2 和 http1 不同

http1.0 每个TCP智能发送一个HTTP请求，发送完成之后断开连接。

http1.1 新增了长连接，TCP复用

http2 改成二进制数据传输，不在使用 ASCII 码、多路复用

-----------------------------------------------------------------------------------------
http 状态码

1xx：信息响应

2xx：成功

3xx：重定向，301 重定向，304 协商缓存

4xx：客户端错误 400、401、403、404

5xx：服务端错误 500、502、504、

-----------------------------------------------------------------------------------------
JavaScript 设计模式

单例模式

策略模式

代理模式

观察者模式

发布订阅模式


-----------------------------------------------------------------------------------------
防抖与节流

防抖：在上次触发的第n秒后在执行

节流：稀释频率，在某短时间内只触发一次

-----------------------------------------------------------------------------------------
ES6常用语法

let const
Promise
解构赋值 ...
async await
Set
Map
Class
Proxy

-----------------------------------------------------------------------------------------

Promise

解决回调地域、异步调用

.then .catch .finally

fulfilled rejected pending

.all

.allSettled：被拒绝的promise 也会返回


-----------------------------------------------------------------------------------------

Class 

函数的语法糖

constructor：初始化数据

继承使用 extends

-----------------------------------------------------------------------------------------

require 与 import


import es6 模块导入，用到的时候才会导入

requrie 服务端模块导入，代码执行的时候就会导入

模块化：commonJS、AMD、CMD、ESModule

CommonJS: 同步的方式加载模块，NodeJS是CommonJS规范的主要实践者，不能在浏览器中使用

Amd库：requre.js，在申明依赖的模块时，会在第一时间加载并执行模块内的代码：

CMD库：seaJS，

AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行

ES6 Module：服务器和浏览器通用方案，编译时加载

-----------------------------------------------------------------------------------------
vue-router

history：需要服务端支持，url变化的时候会重新请求服务端，但我们的目的是不去请求服务器，新增的方法 pushState、replaceState、这些方法浏览器URL更新的时候不会调用接口，所以vue.router push，pushState处理， 拦截 pushState/replaceState、popState 的变化，从而进行页面更新，

router.push、router.replace 改变url pushState/replaceState
首次访问、前进、后退 popstate

hash：浏览器路径后面 #，路由变化的时候，#/hash 变化，这样就可以监听 hash 的变化，从而获取到路由对应的组件，进行页面更新渲染（hashChange）


-----------------------------------------------------------------------------------------

组件通信

props $emit

vuex

EventBus (Vue实例，然后发布订阅模式，)

provide、inject

-----------------------------------------------------------------------------------------

Vuex

状态管理模式库

state：存放数据

mutation: 同步改变数据 commit

action: 异步改变数据 dispatch

-----------------------------------------------------------------------------------------

双向绑定

vue2

数据劫持结合发布订阅者模式， Object.defineProperty，拦截对象属性的set 与 get。利用发布订阅设计模式，在 getter 中进行订阅，在set中发布通知，

Observe 数据劫持，主要用于拦截对象，遍历递归，为所有对象都加上 getter 与 setter，若属性变化了，则通知watcher是否进行更新

Watcher 订阅者，记录每个属性的 依赖方法

Compiler 编译，解析模板，将变量替换为数据。


待定

Vue3为什么弃用了ObjectdefineProperty选择了Proxy

对象上新增属性，Proxy可以监听到，Object.defineProperty不能。
Proxy是对整个对象的代理，而Object.defineProperty只能代理某个属性
数组新增修改，Proxy可以监听到，Object.defineProperty不能。

-----------------------------------------------------------------------------------------

vue2 与 vue3 的区别

响应式原理不同

写法不同，选项式（vue2）、组合式（vue3）

生命周期不同

支持多个根节点

Diff算法优化,vue2全量对比，vue3做了静态标记，每次只需要对比有标记的，还有静态提升、事件侦听器缓存

打包优化 Tree-shaking,移除 JavaScript 上下文中未引用的代码

支持 ts

-----------------------------------------------------------------------------------------

路由守卫

全局守卫

beforeEach

afterEach

beforeResolve

路由独享守卫

beforeEnter

组件内守卫

beforeRouterEnter

beforeRouteLeave

beforeRouteUpdate

顺序：

beforeEach ---> beforeEnter ---> beforeRouterEnter ---> beforeResolve --->  afterEach

-----------------------------------------------------------------------------------------

computed 与 watch

依赖计算

computed attract() {return age + name}

wathch 监听对象的变化

computed 是有缓存的，只要没有变化，就不在计算。这是与 method 的区别

-----------------------------------------------------------------------------------------

虚拟DOM的原理

js描述dom的类型，属性，子元素等。
{
  tagname: 'p',
  xxxxx,
}


patch 双端对比

头尾、尾头、头头、尾尾 进行对比

-----------------------------------------------------------------------------------------
MVVM理解

Model：数据以及业务逻辑
view: 视图更新；视图交互变化
ViewModel：视图模型


-----------------------------------------------------------------------------------------
$nextTick 实现方式

vue采用的是异步更新策略，当监听数据变化时候不会立即更新dom，ersvue采用的是异步更新策略，当监听数据变化时候不会立即更新dom，

接受一个函数，等dom更新完成后，再去执行这个函数。

依赖的是事件循环机制，将传入的函数包装成 异步任务。

promise -> setTimeouot

-----------------------------------------------------------------------------------------
webpack 配置

entry：入口文件，可以是一个或多个

output

loader

plugin

devServer


-----------------------------------------------------------------------------------------
webpack 增量配置

fullhash: 项目内容发生变化就会改变

contenthash：当前文件改变才会改变

chunkhash：当前文件或者依赖文件改变才会改变

css: chunkhash

js：contenthash
-----------------------------------------------------------------------------------------

泛型

<T> ：可以支持多种类型的数据，占位符，具体是什么类型由传入的定

-----------------------------------------------------------------------------------------

前端工程化


模块化、组件化、规范化、自动化

js 分模块打包、css 分模块打包

vue 现在的思想

eslint、目录规范、代码规范、文档规范、git规范、编码规范、

-----------------------------------------------------------------------------------------

从0-1搭建项目

脚手架创建目录

封装axios

封装公共函数

reset样式处理

路由简单编写

vuex编写

UI 组件
-----------------------------------------------------------------------------------------

前端性能优化

减少包体积（分包，将依赖等单独打包）、压缩、去掉console

CDN

gzip

首屏优化

精灵图

图片懒加载/预加载

减少回流重绘

减少闭包

路由懒加载

-----------------------------------------------------------------------------------------

待补充：

虚拟列表
localstorage 存储 map
抽象语法树
Template、 Jsx、 Render
vite 和 wepack 
menorepo
