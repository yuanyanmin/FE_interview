# 第 7 题：垃圾回收机制

## 内存声明周期

1. 分配你所需要的内容
2. 使用分配到的内存（读写）
3. 不需要时将其释放/归还

> JavaScript 与其它手动管理内存的语言不一样的是，在Javascript中，当我们创建变量时，系统会给对象进行自动分配对应的内存空间以及闲置资源回收，也就是不需要我们手动进行分配。但是，正是因为垃圾回收机制导致开发者有着错误的感觉，就是他们不用关心内存管理。

```
const name = "zhansan";//给字符串分配栈内存
const age = 18;//给数值分配栈内存

//给对象以及包含的值分配堆内存
const user = {
  name: "onechuan",
  age: 19
}
//给数组以及包含的值分配堆内存
const arr = ["yichuan","onechuan",18];
//给函数对象分配堆内存
function sum(x,y){
  return x + y;
}

```

## 内存回收机制

**垃圾回收算法**：就是垃圾收集器按照固定的时间间隔，周期性的寻找那些不在使用的变量，然后将其清除或释放内存。

### 标记清除

标记清除分为：标记阶段和清除阶段

首先他会遍历内存上所有的变量，分别给他们打上标记，然后在代码执行过程结束之后，对所使用过的变量取消标记。在清除阶段再把具有标记的内存对象进行整体清除，从而释放内存空间。

整个标记清除算法大致过程就像下面这样
* 垃圾收集器在运行时会给内存中的所有变量都加上一个标记
* 然后从各个根对象开始遍历，把还在上下文变量引用的变量标记去掉标记
* 清理所有带有标记的变量，销毁并回收他们所占用的内存空间
* 最后垃圾回收程序做一次内存清理


**缺点**

通过标记清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，这就造成了内存碎片的问题。内存碎片多了后，如果要存储一个新的需要占据较大的内存空间的对象，就会造成影响。对于通过标记清除产生的碎片，还需要通过标记整理策略进行解决。

### 标记整理

当标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一堆移动，最后清理掉边界的内存

### 引用计数

引用计数是一种不常见的垃圾回收策略，其思路是对每个值多记录其的引用次数。

* 当变量进行声明并赋值后，值的引用数为1
* 当同一个值被赋值给另一个变量时，引用数+1
* 当保存该值的引用的变量被其它值覆盖时候，引用数-1
* 当该值的引用数为0时，表示无法再访问该值，此时就可以进行清除并回收内存

```
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象

```
这种回收策略看起来很方便，但是当其进行循环引用时就会出现问题，会造成大量的内存不会被释放。当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一。


## 内存泄漏与优化

内存泄漏，指在JS中已经分配内存地址的对象由于长时间未进行内存释放或无法清除，造成了长期占用内存，使得内存资源浪费，最终导致运行的应用响应速度变慢以及最终崩溃的情况。

在代码中创建对象和变量时会占据内存，但是JS基于自己的内存回收机制是可以确定哪些变量不再需要，并将其进行清除。但是，当你的代码中存在逻辑缺陷时，你以为你已经不需要，但是程序中还存在这引用，这就导致程序运行完后并没有进行合适的回收所占有的内存空间。运行时间越长占用内存越多，随之出现的问题就是：性能不佳、高延迟、频繁崩溃。

造成内存泄漏的常见原因有：

* 过多的缓存。（及时清理过多的缓存）
* 滥用闭包。（尽量避免使用大量的闭包）
* 定时器或回调太多。（与节点活数据相关联的计时器不在需要时，DOM节点可以清除，整个回调函数也不在需要。手动清除定时器）
* 太多的无效的DOM引用。（DOM 删除了，但节点的引用还在，可以给删除的DOM节点引用设置为null）
* 滥用全局变量。
* 程序逻辑。（避免死循环）
* DOM 对象和 JS 对象相互引用。


**参考链接**

[「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#heading-7)
[内存管理-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management)
