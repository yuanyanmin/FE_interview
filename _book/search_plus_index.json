{"./":{"url":"./","title":"FE 汇总面试题","keywords":"","body":"Introduction 记录前端相关面试题。 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-11 "},"chapter_css/":{"url":"chapter_css/","title":"CSS 面试题","keywords":"","body":"chapter_css Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-11 "},"chapter_css/section_1.html":{"url":"chapter_css/section_1.html","title":"第 1 题：BFC","keywords":"","body":"第 1 题：BFC 及其应用 常见的定位方案 普通流 在普通流中，元素按照其 HTML 中的先后位置至上而下布局。在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位. 浮动 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或者右边偏移。 浮动定位 在绝对定位布局中，元素会整体脱离普通流 概念 BFC 即 块级格式化上下文。可以看做是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。 触发条件 body 根元素 浮动元素 float 除了 none 以外的值 绝对定位元素 position (absolute、fixed) display 为 inline-block、flex、table-cells overflow 除了 visible 以外的元素 特性及其应用 外边距折叠（margin折叠） 清除浮动 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 "},"chapter_css/section_2.html":{"url":"chapter_css/section_2.html","title":"第 2 题：div 水平垂直居中","keywords":"","body":"第 2 题：div 水平垂直居中 第一种 定宽高 定位 + 负 margin .element { position: absolute; left: 50%; top: 50%; margin-left: -250px; margin-top: -250px; width: 500px; height: 500px; background-color: red; } 定位 + margin: auto 原理 .element { position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; width: 500px; height: 500px; background-color: red; } 第二种 不定宽高 定位 + transform .element { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 500px; height: 500px; background-color: red; } flex .parent { display: flex; justify-content: center; align-items: center; width: 600px; height: 600px; background-color: greenyellow; } .element { width: 500px; height: 500px; background-color: red; } Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 "},"chapter_css/section_3.html":{"url":"chapter_css/section_3.html","title":"第 3 题：Flex","keywords":"","body":"Flex Flex 布局是什么 弹性布局，用来为盒装模型提供最大的灵活性 .box { display: flex; } 容器的属性 flex-direction 决定主轴的方向，即项目的排列方向 .box { flex-direction：row | row-reverse | column | column-reverse } row： 水平方向，起点在左端 row-reverse：水平方向，起点在右端 column：垂直方向，起点在上沿 column-reverse：垂直方向，起点在下沿 flex-wrap 若一条轴线排不下如何换行 .box { flex-wrap：nowrap | wrap | wrap-reverse } nowrap： 不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow 是 flex-direction 与 flex-wrap 的简写形式，默认为 row nowrap .box { flex-flow： || } justify-content 主轴上的对齐方式 .box { justify-content: flex-start | flex-end | center | space-between | space-around } flex-start：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等 align-items 交叉轴上如何对齐 .box { align-items: flex-start | flex-end | center | baseline | stretch } flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch：若项目未设置高度，则将占满整个容器的高度 align-content 多根轴线的对齐方式 .box { align-content：flex-start | flex-end | center | space-between | space-around | stretch } flext-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：没跟轴线两侧的间隔都相等 stretch：轴线占满整个交叉轴 项目的属性 order 定义项目的排序顺序，数值越小越靠前，默认为0 .item { order: } flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 .item { flex-grow： } 如果所有项目的 flex-grow 属性都为1，则他们将等分剩余空间。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 flex-shrink 定义项目的缩小比例，默认为，即如果空间不足，则项目将缩小 .item { flow-shrink: } 如果所有项目的 flex-shrink 属性都为1，则空间不足时，都将等比例缩小。如果一个项目的 flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 负值对该属性无效 flex-basis 定义了在分配多余的剩余空间之前，项目占据的主轴空间。默认为auto,即项目本来大小 .item { flex-basis: | auto } 它可以设为跟 width 和 height 属性一样的值，则项目将占据固定空间 flex 是 flex-grow、flex-shrink 和 flex-basis的简写，默认为 0 1 auto。 .item { flex: none | [ ? || ] } 该属相有两个快捷键：auto（1 1 auto）和 none （ 0 0 auto） flex: 1 （1 1 0%） align-self 允许单个项目有与其他项目不一样的对齐方式，可以覆盖 aligin-items 属性，默认为 auto,表示继承父元素的 align-items 属性。 .item { align-self：auto | flex-start | flex-end | center | baseline | stretch } Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_css/section_4.html":{"url":"chapter_css/section_4.html","title":"第 4 题：双飞翼布局与圣杯布局","keywords":"","body":"第 4 题：双飞翼布局与圣杯布局 header 和 footer ，高度固定 中间的是一个三栏布局，两侧宽度固定不变，中间部分自动填充整个区域 圣杯布局 body { min-width: 550px; } #container { padding-left: 200px; padding-right: 150px; } #container .column { float: left; } #center { width: 100%; } #left { width: 200px; margin-left: -100%; position: relative; right: 200px; } #right { width: 150px; margin-right: -150px; } #footer { clear: both; } 双飞翼布局 body { min-width: 500px; } #container { width: 100%; } .column { float: left; } #center { margin-left: 200px; margin-right: 150px; } #left { width: 200px; margin-left: -100%; } #right { width: 150px; margin-left: -150px; } #footer { clear: both; } 总结 相同之处 布局类似，都实现三栏布局 使用 float 浮动向左脱离文档流，让左中右三列浮动，通过外边距行成三列布局 不同之处 圣杯布局是通过 float 搭建布局 + margin 使三列布局到同一行上 + relative 相对定位调整位置 双飞翼布局是通过 float + margin 圣杯布局是通过给外部容器加 padding，通过相对定位把两边定位出来 双飞翼布局是靠在中间这层外面套一层 div 加 padding 将内容挤出来 参考链接 链接 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-17 "},"chapter_css/section_5.html":{"url":"chapter_css/section_5.html","title":"第 5 题：scope 作用","keywords":"","body":"第 5 题：scope 作用 样式隔离 若style标签加了 scoped 属性，那么再组件渲染为 DOM 时，会对每个组件中的 DOM 元素添加格式为 data-v[hash:8]的属性，然后该组件的所有选择器也会添加上对应的 data-v[hash:8] 属性选择器来只对自身组件产生影响，以此来实现样式隔离 样式穿透原理 /deep/ >>> 等都会被渲染为父组件的 data-v[hash]。 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-16 "},"chapter_javascript/":{"url":"chapter_javascript/","title":"Javascript 面试题","keywords":"","body":"Javascript 面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 "},"chapter_javascript/section_1.html":{"url":"chapter_javascript/section_1.html","title":"第 1 题：事件循环机制","keywords":"","body":"第 1 题：事件循环机制 js分为同步代码和异步代码。执行js的时候，会从上往下执行。遇到同步代码时候，会执行当前同步代码，然后继续向下执行，遇到异步代码的时候，会将该异步代码放到异步队列中，继续向下执行，直到所有的同步任务都执行完毕。从异步队列中取任务继续执行。 基本概念 调用栈：执行JS代码的。会记录函数调用的过程，并将函数的变量等信息以栈帧的形式压入，当执行完函数后，将栈顶的帧弹出。 堆：用来存储对象变量或者其他复杂的数据结构变量 任务队列：存储待执行的任务：eg. 点击事件、回调函数等。任务又包括 宏任务和微任务。 宏任务与微任务 微任务：Promise、Async/Await、MutationObserver 宏任务：Ajax、setTimeout、setInterval、script 整体代码、UI render Event Loop 过程 同步代码，一行一行放在 Call Stack（调用栈） 中执行 遏到异步，会先“记录”下，等待执行时机(selTimeuul.Ajax)。时机到了，将之前“记录”的化码放入Callback Queue(回调函数队列） 当 Call Stack 为空 (同步代码执行完)，Event Loop 开始工作 Event Locp 轮询查找 Calback Queue 中是否有可执行的码。如果有，将代码移动到 Call Stack 中执行 Event Loop 如果没有找到可以执行代码，则会继续轮询查找 首先 script 整体作为宏任务执行，执行同步代码，当遇到异步任务时，如果是宏任务就会交给其他线程处理，并放入对应的任务队列中。微任务放入微任务队列，主线程挂起这些异步任务，接着执行后面的代码 当前执行栈清空会先执行所有的微任务，如果还遇到微任务也会将其放入当前微任务队列后，直到所有执行完。 然后主线程根据调度优先级从宏任务队列中适合执行的任务执行，然后不断重复以上操作。 总结 EventLoop 就是通过事件循环的机制，当执行栈空闲时，主线程判断任务队列是否有合适的任务，取出最老的一个任务将其压入调用栈中执行，执行完后再次出栈，如此反复不断循环，就是所谓的事件循环机制 代码阅读 console.log(1) setTimeout(function() { console.log(2) }) new Promise(function (resolve) { console.log(3) resolve() }).then(function () { console.log(4) }).then(function() { console.log(5) }) console.log(6) // 1 3 6 4 5 2 setTimeout(()=>{ console.log(0) },0) new Promise((resolve)=>{ console.log(1) resolve() }).then(()=>{ console.log(2) }).then(()=>{ console.log(3) }) console.log(4) // 1 4 2 3 0 new Promise((resolve,reject)=>{ console.log(\"p1-0\") resolve() }).then(()=>{ console.log(\"p1-1\") new Promise((resolve,reject)=>{ console.log(\"p2-0\") resolve() }).then(()=>{ console.log(\"p2-1\") }).then(()=>{ console.log(\"p2-2\") }) }).then(()=>{ console.log(\"p1-2\") }) // p1-0 p1-1 p2-0 p2-1 p1-2 p2-2 new Promise((resolve, reject) => { console.log(\"p1-0\") resolve() }).then(() => { setTimeout(() => { console.log('macrotask-1') new Promise((resolve, reject) => { console.log(\"p2-0\") resolve() }).then(() => { setTimeout(() => { console.log('macrotask-2') }, 0) console.log(\"p2-1\") }).then(() => { console.log(\"p2-2\") }) }, 0) console.log(\"p1-1\") }).then(() => { console.log(\"p1-2\") }) // p1-0、p1-1、p1-2、macrotask-1、p2-0、p2-1、p2-2、macrotask-2 async function async1() { console.log(\"a1-0\"); await async2(); console.log(\"a1-1\"); setTimeout(() => { console.log('macro-2') }, 0) } async function async2() { console.log(\"a2-0\"); setTimeout(() => { console.log('macro-3') }, 0) } setTimeout(() => { console.log('macro-1') }, 0) async1(); // a1-0、a2-0、a1-1、macro-1、macro-3、macro-2 Promise 构造函数中函数体的代码都是立即执行的 Promise题库 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-17 "},"chapter_javascript/section_2.html":{"url":"chapter_javascript/section_2.html","title":"第 2 题：深拷贝","keywords":"","body":"第 2 题：深拷贝 Object.assign Object.assign 默认是对对象进行深拷贝，它只对最外层的进行深拷贝，也就是当对象内嵌套有对象的时候，被嵌套的对象进行的还是浅拷贝； function cloneDeepAssign(obj){ return Object.assign({},obj) //Object.assign({},obj) } JSON实现深拷贝 function cloneDeepJson(obj){ return JSON.parse(JSON.stringify(obj)) } 会忽略 undefined和symbol； 不可以对Function进行拷贝，因为JSON格式字符串不支持Function，在序列化的时候会自动删除； 诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失； 不支持循环引用对象的拷贝;（循环引用的可以大概地理解为一个对象里面的某一个属性的值是它自己） 递归实现 function cloneDeepDi(obj){ const newObj = {}; let keys = Object.keys(obj); let key = null; let data = null; for(let i = 0; iStructuredClone structuredClone是结构化拷贝算法的实现，能够实现几乎对所有数据类型的深拷贝。目前最新版本的浏览器都已经原生支持。 structuredClone(value) structuredClone(value, { transfer }) // Create an object with a value and a circular reference to itself. const original = { name: \"MDN\" }; original.itself = original; // Clone it const clone = structuredClone(original); console.assert(clone !== original); // the objects are not the same (not same identity) console.assert(clone.name === \"MDN\"); // they do have the same values console.assert(clone.itself === clone); // and the circular reference is preserved Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-17 "},"chapter_javascript/section_3.html":{"url":"chapter_javascript/section_3.html","title":"第 3 题：闭包","keywords":"","body":"第 3 题：闭包 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来 理解闭包 function f1(){ var n = 999; function f2(){ console.log(n); } return f2 //返回内部函数f2，这样在f1中就能读取f2的数据和函数等价于window.f2 = f2; } var result = f1(); result(); //999 f1是一个外部函数，变量n是外部函数的局部变量，f2是嵌套在f1中的一个内部函数，在内部函数f2中调用了外部函数f1的变量n,所以f2和变量n就组成了一个闭包。 那么，我们就可以得出产生闭包的条件： 一个外部函数里面嵌套着一个内部函数；比如外部函数f1里面嵌套了一个内部函数f2 一个嵌套的内部函数调用了外部函数的内部变量或函数；比如f2内部函数调用了外部函数f1的变量n 只要满足以上两个条件，就产生了闭包。 那你可能会问为什么要return f1呢？ 因为在JS中，只要内部函数才能够读取外部函数的内部变量或数据，反之则不行，如果你不return f2，那你将无法使用f2这个闭包，return f2是为了在f1中能使用f2的变量和数据，与闭包没有关系的。 那到底什么是闭包呢？ 可以通俗理解成：闭包就是有权访问另一个函数作用域中内部变量或数据的函数，因为在JS中，只要内部函数能能够读取外部函数的变量或数据，反之就不行，所有可以将闭包简单理解成，定义在一个函数内部的函数。 总结： 闭包就是有权访问另一个函数内部变量的函数。 闭包产生的原因： 内部函数存在对外部函数局部变量的引用就会导致闭包。 使用场景 读取内部函数的变量 function f1(){ var n = 999; function f2(){ console.log(n); } return f2； } var result = f1(); result();//999 函数作为参数 var n = 999; function f1(){ var n = 1000; function f2(){ console.log(n); } return f2 } function f3(p){ var n = 1001; p(); } f3(f1());//1000 IIFE(自执行函数) ``` var n = 999; (function f1(){ console.log(n); })() //999 * 循环赋值 for(var i = 0; i ``` 节流防抖 第一次点击的时候，我们会let一个time一个定时器，如果不采用闭包的话，下次触发函数会重新创建一个新的定时器，两个定时器的引用不同，是没有关联的，使用闭包可以直接在内存中找到之前创建的计时器，调用就可以直接拿到对应的定时器的时间 为什么需要闭包 因为全局变量容易污染环境，而局部变量又无法长期驻留内存，于是我们就需要一种机制，既能长期保存变量又不污染全局，这就是闭包。 注意点 因为使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制（简称GC机制）回收，多度使用闭包会过度占用内存，造成内存泄漏。 总结 闭包是有权访问另一个函数作用域变量的函数 闭包一般是函数嵌套，一个函数返回另外一个函数，内部函数访问外部函数的变量就形成了一个闭包 闭包的优点是可以私有化变量，将变量私有化到函数内部，并在私有化的基础上进行数据保持 闭包在防抖节流函数柯里化，都应用里数据保持这个特性 闭包的缺点是容易造成内存泄露，因为闭包创建的变量会一直存在内存中，需要及时置空，否则会造成内存泄露，影响程序性能 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-18 "},"chapter_javascript/section_4.html":{"url":"chapter_javascript/section_4.html","title":"第 4 题：数组遍历方式","keywords":"","body":"第 4 题：数组遍历方式 for 循环 可以使用 break 和 continue ，且能改变原数组的值 while循环 功能和for一样 forEach 只能遍历，不支持 break 和 continue, 函数返回值为 undefined，return 也终止不了循环 every 判断数组内所有元素是否都能通过指定函数的测试 some 和every()做对比，该方法只要数组中存在某一个符合条件的就返回true filter 过滤数组，返回新数组 map 对每一个数组元素应用函数，并返回一个新的数组 reduce 遍历数组全部元素，将函数处返回的数字累加到一起，并返回这个累加结果，可初始化一个值 arr.reduce((prev,cur,index,arr)=>{ },init) arr: 表示将要原数组 prev:表示上一次调用回调时的返回值，或者初始值init cur:表示当前正在处理的数组元素 index:表示正在处理的数组元素的索引，若提供init值，则索引为0，否则索引为1 init: 表示初始值 for...in 迭代对象，由于数组是特殊的对象，也可以进行迭代，但不推荐 以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性 for (let prop in obj) { console.log(\"obj.\" + prop + \" = \" + obj[prop]); } for...of 可遍历多种可迭代对象，支持 break 和 return 在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 for (let value of iterable) { //statements } Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-18 "},"chapter_javascript/section_5.html":{"url":"chapter_javascript/section_5.html","title":"第 5 题：axios","keywords":"","body":"第 5 题：axios 创建 Axios 实例 let instance = axios.create({ headers:{ 'content-type':'application/x-www-form-urlencoded' } }) 请求拦截 这个拦截器会在你发送请求之前运行，此处请求拦截器的功能是：每次请求前去判断是否有token，如果token存在则在请求头加上这个token,后台会判断这个token是否过期。 // http request拦截器 instance.interceptors.request.use( config=>{ const token = localStorage.getItem('token');//此处用这个localStorage 也可以用store，因为一般登录后都会将登录信息存储到vuex中，但是如果不存储到localsStorage的话，当前页面刷新时，vuex中的内容会消失。 if(token){ config.headers.authorization = token //请求头加上token } return config },err=>{ return Promise.reject(err); } ) 响应拦截器 这个拦截器会在拿到后台接口返回的数据后，进行响应处理。比如数据正确返回是code是200，如果code是500,则需要拦截一下。 instance.interceptors.response.use( response = { //拦截响应，做统一处理 if(response.data.code){ switch(response.data.code){ case 1002: store.state.isLogin = false;//store中有个isLogin表示登录状态，这个视具体情况而定 router.replace({ path:'login', query:{ redirect:router.currentRoute.fullPath } }) } } return response }, //接口错误状态处理，也就是说无响应时的处理 error =>{ return Promise.reject(error.response.status);//接口返回的错误信息 } ) 进入error 情况 Axios.interceptors.request.use（config={ //这里会最先拿到你的请求配置 },err=>{ // 这里极少情况会进来，暂时没有找到主动触发的方法，估计只有浏览器不兼容时才会触发，欢迎后面同学补充 // 看了几个GitHub的issue，有人甚至提出了这个方法是不必要的（因为没有触发的场景），不过还是建议大家按照官方的写法，避免不必要的错误 // 进来之后没法发起请求 }） Axios.interceptors.response.use（res ={ //这里会最先拿到你的response // 只有返回的状态码是2xx，都会进来这里 },err=>{ // 目前发现三种情况会进入这里： // 1. http状态码非2开头的都会进来这里，如404,500等 // 2. 取消请求也会进入这里，CancelToken，可以用axios.isCancel(err)来判断是取消的请求 // 3. 请求运行有异常也会进入这里，如故意将headers写错：axios.defaults.headers = '123',或者在request中有语法或解析错误也会进入这里 // 进入这里意味着请求失败，axios会进入catch分支 }） Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-18 "},"chapter_es6/":{"url":"chapter_es6/","title":"ES6 面试题","keywords":"","body":"ES6 面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 "},"chapter_es6/section_1.html":{"url":"chapter_es6/section_1.html","title":"第 1 题：ES6常用语法","keywords":"","body":"第 1 题：ES6常用语法 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 "},"chapter_es6/section_2.html":{"url":"chapter_es6/section_2.html","title":"第 2 题：Promise","keywords":"","body":"第 2 题：Promise Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 "},"chapter_es6/section_3.html":{"url":"chapter_es6/section_3.html","title":"第 3 题：Class","keywords":"","body":"第 3 题：Class Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 "},"chapter_es6/section_4.html":{"url":"chapter_es6/section_4.html","title":"require 与 import","keywords":"","body":"require 与 import CommonJS 模块化方案 require/exports 是为服务器端开发设计的。服务器模块系统同步读取模块文件内容，编译执行后得到的模块接口。 原生浏览器不支持 require/exports，可使用支持 CommonJS 模块规范的 Browsersify、webpack 等打包工具，它们会将 require/exports 转换成能在浏览器使用的代码。 import/export 在浏览器中无法直接使用，我们需要在引入模块的 元素上添加type=\"module\" 属性。 用法 require/exports ``` const fs = require('fs') exports.fs = fs moudule.exports = fs exports = module.exports = {}; * import/export import fs from 'fs' import {readFile} from 'fs' //从 fs 导入 readFile 模块 import {default as fs} from 'fs' //从 fs 中导入使用 export default 导出的模块 import * as fileSystem from 'fs' //从 fs 导入所有模块，引用对象名为 fileSystem import {readFile as read} from 'fs' //从 fs 导入 readFile 模块，引用对象名为 read export default fs export const fs export function readFile export {readFile, read} export * from 'fs' ``` Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-20 "},"chapter_vue/":{"url":"chapter_vue/","title":"Vue 面试题","keywords":"","body":"vue 相关面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 "},"chapter_vue/section_1.html":{"url":"chapter_vue/section_1.html","title":"第 1 题：vue-router","keywords":"","body":"第 1 题：vue-router 原理 前端路由 web 前端单页面中，路由描述的是 URL 与 UI 之间的映射关系，这种关系是单向的，即 URL 变化引起 UI 更新（无须刷新页面） hash 实现 hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，最重要的是改变 URL 中的 hash 部分不会引起页面刷新。 我们可以通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种： 通过浏览器前进后退改变 URL 通过标签改变 URL 通过 window.location 改变 URL history 实现 HTML5 标准的发布，history 的 api 增加了两个 API。pushState 和 replaceState。通过这两个 API 可以改变 URL 地址且不会发送请求。同时还有 popstate 事件。 用了这种实现方式，单页面路由的 url 就不会多出一个 #，变得更新加美观，但因为没有 # 号，所以当用户刷新页面之类的操作时候，浏览器还是会给服务器端发送请求。为了避免这种情况，所以这个实现需要服务器的支持，需要吧所有路由都重定向到根页面。 通过 pushState/replaceState或者标签改变 URL 不会触发页面刷新，也不会触发popstate方法。所以我们可以拦截 pushState/replaceState的调用和标签的点击事件来检测 URL 变化，从而触发 router-view 的视图更新 通过浏览器前进后退改变 url,或者通过 js 调用 history 的 back、go、forward方法，都会触发 popstate 事件，所以我们可以监听 popstate来触发 route-view 的视图更新 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 "},"chapter_vue/section_2.html":{"url":"chapter_vue/section_2.html","title":"第 2 题：组件通信","keywords":"","body":"第 2 题：组件通信 props/$emit 父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。 EventBus($emit/$on) 这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级 var Event=new Vue(); Event.$emit(事件名,数据); Event.$on(事件名,data => {}); vuex $attr/$listeners provide/inject // 父 export default { provide: { name: '浪里行舟' } } // 子 export default { inject: ['name'], mounted () { console.log(this.name); // 浪里行舟 } } $parent/$children 与 ref ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-18 "},"chapter_vue/section_3.html":{"url":"chapter_vue/section_3.html","title":"第 3 题：Vuex","keywords":"","body":"第 3 题：Vuex Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上 Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块,由组件中的$store.dispatch('action 名称', data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法，由actions中的commit('mutation 名称')来触发。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-18 "},"chapter_vue/section_4.html":{"url":"chapter_vue/section_4.html","title":"第 4 题：双向绑定原理","keywords":"","body":"第 4 题：双向绑定原理 vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对 data 的 getter/setter 方法进行拦截（Object.defineProperty 或者 Proxy）,利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应 vue2 基于 Object.defineProperty() 重新定义 get 和 set 方法实现的。修改触发 set 方法赋值，获取或触发 get 方法取值，并通过数据劫持发布信息。 vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。 需要observer(观察者)对数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 compile(模板解析器)解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher(订阅者)是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果 vue3 3.x的与2.x的核心思想一致，只不过数据的劫持使用Proxy而不是Object.defineProperty，只不过Proxy相比Object.defineProperty在处理数组和新增属性的响应式处理上更加方便 问题：为什么用Proxy 代替 defineProperty ？ Object.defineProperty Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象 为什么能够实现响应式？ 通过 defineProperty 两个属性 get 与 set get 属性的 getter函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象。返回值会被用作属性的值 set 属性的 set 函数，当属性值被修改时，会调用此函数，接受一个参数（被赋予的新值），会传入赋值的this对象，默认为 undefined function update() { app.innerText = obj.foo } function defineReactive(obj, key, val) { Object.defineProperty(obj, key, { get() { console.log(`get ${key}:${val}`); return val }, set(newVal) { if (newVal !== val) { val = newVal update() } } }) } // 调用defineReactive，数据发生变化触发update方法，实现数据响应式 const obj = {} defineReactive(obj, 'foo', '') setTimeout(()=>{ obj.foo = new Date().toLocaleTimeString() },1000) 缺点 检测不到对象属性的添加和删除 数组API无法监听到 需要对每个属性进行监听，若嵌套对象，需要深层监听，造成性能问题 Proxy Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了 function reactive(obj) { if (typeof obj !== 'object' && obj != null) { return obj } // Proxy相当于在对象外层加拦截 const observed = new Proxy(obj, { get(target, key, receiver) { const res = Reflect.get(target, key, receiver) console.log(`获取${key}:${res}`) return res }, set(target, key, value, receiver) { const res = Reflect.set(target, key, value, receiver) console.log(`设置${key}:${value}`) return res }, deleteProperty(target, key) { const res = Reflect.deleteProperty(target, key) console.log(`删除${key}:${res}`) return res } }) return observed } 总结 Object.defineProperty 只能遍历对象属性进行劫持 Proxy 可以劫持整个对象，并返回一个新对象 Proxy 可以直接监听数组的变化 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-18 "},"chapter_vue/section_5.html":{"url":"chapter_vue/section_5.html","title":"第 5 题：生命周期","keywords":"","body":"第 5 题：生命周期 生命周期就是组件或者实例，从创建到被销毁（初始化数据、编译模板、挂载DOM、渲染-更新-渲染）的过程。 Vue2生命周期阶段 第一阶段（创建阶段）：beforeCreate、created 第二阶段（挂载阶段）：beforeMount(render)、mounted 第三阶段（更新阶段）：beforeUpdate、updated 第四阶段（销毁阶段）：beforeDestory、destroyed 生命周期钩子函数 beforeCreate 在实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用 在这个阶段，数据获取不到，真实dom元素也是没有渲染出来的 created 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用 在这个阶段，可以访问到数据了，但是页面当中真实dom节点还是没有渲染出来，在这个钩子函数里面，可以进行相关初始化事件的绑定、发送请求操作 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 代表dom马上就要被渲染出来了，但是却还没有真正的渲染出来，这个钩子函数与created钩子函数用法基本一致，可以进行相关初始化事件的绑定、发送ajax操作 mounted 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。 挂载阶段的最后一个钩子函数,数据挂载完毕，真实dom元素也已经渲染完成了,这个钩子函数内部可以做一些实例化相关的操作 beforeUpdate 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。 这个钩子函数初始化的不会执行,当组件挂载完毕的时候，并且当数据改变的时候，才会立马执行,这个钩子函数获取dom的内容是更新之前的内容 updated 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。 这个钩子函数获取dom的内容是更新之后的内容生成新的虚拟dom，新的虚拟dom与之前的虚拟dom进行比对，差异之后，就会进行真实dom渲染。在updated钩子函数里面就可以获取到因diff算法比较差异得出来的真实dom渲染了。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 当组件销毁的时候，就会触发这个钩子函数代表销毁之前，可以做一些善后操作,可以清除一些初始化事件、定时器相关的东西 destroyed 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 Vue实例失去活性，完全丧失功能 vue3生命周期 父子生命周期 加载渲染过程 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted 更新过程 父beforeUpdate->子beforeUpdate->子updated->父updated 销毁过程 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_vue/section_6.html":{"url":"chapter_vue/section_6.html","title":"第 6 题：Vue2 与 Vue3 区别","keywords":"","body":"第 6 题：Vue2 与 Vue3 区别 生命周期 对于生命周期来说，整体上变化不大，只是大部分生命周期钩子名称上 + “on”，功能上是类似的。不过有一点需要注意，Vue3 在组合式API（Composition API，下面展开）中使用生命周期钩子时需要先引入，而 Vue2 在选项API（Options API）中可以直接调用生命周期钩子 // vue3 import { onMounted } from 'vue'; // 使用前需引入生命周期钩子 onMounted(() => { // ... }); // 可将不同的逻辑拆开成多个onMounted，依然按顺序执行，不会被覆盖 onMounted(() => { // ... }); // vue2 export default { mounted() { // 直接调用生命周期钩子 // ... }, } 多根节点 Compositon Api vue2 是选项式API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置 Vue3 组合式API（Composition API）则很好地解决了这个问题，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案。 响应式原理 Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy。 虚拟DOM Diff算法优化 打包优化 Typescript 支持 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_vue/section_7.html":{"url":"chapter_vue/section_7.html","title":"第 7 题：路由守卫","keywords":"","body":"第 7 题：路由守卫 全局路由钩子 beforeEach(to, from, next) 全局前置守卫，在路由跳转前触发，参数包括 to,from,next 三个 beforeResolve(to, from, next) 全局解析守卫，在路由跳转前触发，参数包括 to,from,next 三个 这和 router.beforeEach 类似，因为它在每次导航时都会触发，不同的是，解析守卫刚好会在导航被确认之前、所有组件内守卫和异步路由组件被解析之后调用 afterEach(to, from) 全局后置钩子，参数包括to,from没有了next router.beforeEach((to, from, next) => { // to 将要访问的路径 // from 代表从哪个路径跳转而来 // next 是一个函数，表示放行 // next() 放行 next('/login') 强制跳转 }) 路由独享的守卫 beforeEnter(to, from, next) 是指在单个路由配置的时候也可以设置的钩子函数，只在进入路由时触发，不会在 params、query 或 hash 改变时触发 const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) => { // ... } } ] }) 组件内的守卫 beforeRouteEnter(to, from, next) 路由进入之前调用，参数包括to，from，next。不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建，不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数 beforeRouteEnter (to, from, next) { // 这里还无法访问到组件实例，this === undefined next( vm => { // 通过 `vm` 访问组件实例 }) } beforeRouteUpdate(to, from, next) 在当前路由改变时(/foo/:id)，并且该组件被复用时调用，可以通过this访问实例 beforeRouteUpdate (to, from) { // just use `this` this.name = to.params.name } beforeRouteLeave(to, from, next) 导航离开该组件的对应路由时调用，可以访问组件实例this,通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 false 来取消。 导航守卫回调参数 to：目标路由对象； from：即将要离开的路由对象； next：他是最重要的一个参数，他相当于佛珠的线，把一个一个珠子逐个串起来。以下注意点务必牢记： 但凡涉及到有next参数的钩子，必须调用next() 才能继续往下执行下一个钩子，否则路由跳转等会停止。 如果要中断当前的导航要调用next(false)。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到from路由对应的地址。（主要用于登录验证不通过的处理） 当然next可以这样使用，next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。意思是当前的导航被中断，然后进行一个新的导航。可传递的参数与router.push中选项一致。 在beforeRouteEnter钩子中next((vm)=>{})内接收的回调函数参数为当前组件的实例vm，这个回调函数在生命周期mounted之后调用，也就是，他是所有导航守卫和生命周期函数最后执行的那个钩子。 next(error): (v2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 完整的流程 导航被触发 在失活的组件里调用 beforeRouteLeave 守卫 调用全局的 beforeEach 守卫 在重用的组件里调用 beforeRouteUpdate 守卫 在路由配置里调用 beforeEnter 解析异步路由组件 在被激活的组件里调用 beforeRouteEnter 调用全局的 beforeResolve 守卫 导航被确认 调用全局的 afterEach 钩子 触发 DOM 更新 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_vue/section_8.html":{"url":"chapter_vue/section_8.html","title":"第 8 题：computed 与 watch","keywords":"","body":"第 8 题：computed 与 watch 相同点 计算属性和监听属性，本质上都是一个 watcher 实例，他们都通过响应式系统预数据，页面建立通信。 不同点 计算属性存在缓存 监听的逻辑有差异， 监听属性是目标值变了,它去执行函数，而计算属性是函数的值变了, 它重新求值 页面刷新以后, 计算属性会默认立即执行, 而watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true） method 与 computed 对比 我们也可以使用methods实现前面的需求，当有多个地方在使用，对应的methods函数会被调用多次，函数内部的逻辑也需要执行多次；而计算属性因为存在缓存，只要数据未发生变化，则多次访问计算属性对应的函数只会执行一次 缓存的理解 计算属性有对应的 watcher，watcher 实例有一个 dirty 属性控制缓存的读取，当 watcher.dirty 为 true 时，调用计算属性 get 方法重新求值；当 watcher.dirty 为 false 时，直接返回 watcher.value 的值 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_Webpack/":{"url":"chapter_Webpack/","title":"Webpack 面试题","keywords":"","body":"Webpack 面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 "},"chapter_Webpack/section_1.html":{"url":"chapter_Webpack/section_1.html","title":"第 1 题：webpack里面有哪些内容","keywords":"","body":"第 1 题：webpack里面有哪些内容 webpack 作用 模块打包：可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。 编译兼容：通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less, .vue, .jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率 能力扩展：通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。 打包运行原理 读取webpack配置参数 启动 webpack,创建 Compiler 对象并开始解析项目 从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树 对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转为JavaScript文件 整个过程中 webpack 会通过发布订阅模式，向外抛出一些 hooks,而 webpack的插件即可通过监听这些关键的事件节点，执行插件任务而达到干预输出结果的目的 sourceMap { \"version\" : 3, // Source Map版本 \"file\": \"out.js\", // 输出文件（可选） \"sourceRoot\": \"\", // 源文件根目录（可选） \"sources\": [\"foo.js\", \"bar.js\"], // 源文件列表 \"sourcesContent\": [null, null], // 源内容列表（可选，和源文件列表顺序一致） \"names\": [\"src\", \"maps\", \"are\", \"fun\"], // mappings使用的符号名称列表 \"mappings\": \"A,AAAB;;ABCDE;\" // 带有编码映射数据的字符串 } Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_Webpack/section_2.html":{"url":"chapter_Webpack/section_2.html","title":"第 2 题：webpack哪些常用的配置","keywords":"","body":"第 2 题：webpack哪些常用的配置 配置项 entry：入口文件，可以是一个或多个 JavaScript 文件，通过这个文件，Webpack 将会处理整个应用。 output：输出配置选项，用于告诉 Webpack 将打包后的文件输出到哪里。可以定义 output.path、output.filename 和 output.publicPath 等。 module：模块配置选项，使用不同的 loader 可以让 Webpack 处理不同类型的文件。例如，对于 CSS 文件，可以使用 css-loader 和 style-loader 处理。 resolve：解析配置选项，用于告诉 Webpack 该如何解析模块依赖。可以设置 resolve.alias、resolve.extensions、resolve.modules 等。 plugins：插件配置选项，使用不同的插件可以增强 Webpack 的功能。例如，使用 html-webpack-plugin 可以将打包后的 js 文件自动引用到 HTML 文件中。 devServer：开发服务器配置选项，提供了一个简单的 web 服务器和实时重载功能，可以通过 devServer.contentBase、devServer.port、devServer.proxy 等进行配置。 optimization：优化配置选项，可以使用 optimization.splitChunks 和 optimization.runtimeChunk 配置代码拆分和运行时代码提取等优化策略。 externals：外置扩展配置选项，用于配置排除打包的模块。例如，可以将 jQuery 作为外置扩展，避免将其打包到应用程序中。 loader file-loader url-loader css-loader style-loader scss-loader less-loader postcss-loader eslint-loader plugins HtmlWebpackPlugin clear-webpack-plugin copy-webpack-plugin mini-css-extract-plugin terser-webpack-plugin：压缩代码 optimize-css-assets-webpack-plugin：压缩css代码 image-webpack-loader 或 img-loader：压缩图片 postcss-sprities 活 webpack-spritesmith：合并图片 webpack-merge：用于优化配置文件 splitChunksPlugin：代码分隔 webpack-bundle-analyzer：可视化的打包优化插件 webpack-dev-serve HRM：热更新 babel：将es678转为es5 babel-preset-env：兼容哪些浏览器 babel/polyfill：没有对应关系就是指E5中根本就没有对应的语法, 例如Promise, includes等方法是ES678新增的。ES5中根本就没有对应的实现, 这个时候就需要再增加一些额外配置, 让babel自己帮我们实现对应的语法 babel/parser：将js代码转换为ast抽象语法树 babel/generator：将ast抽象语法树转换为js代码 babel/traverse：遍历抽象语法树 babel/types：创建ast抽象语法树 html-withing-loader：实现html中图片的打包 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_typescript/":{"url":"chapter_typescript/","title":"Typescript 面试题","keywords":"","body":"typescript 面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_typescript/section_1.html":{"url":"chapter_typescript/section_1.html","title":"第 1 题：泛型的理解","keywords":"","body":"泛型 介绍 泛型是程序设计语言的一种分格或者范式 泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型在 typescript 中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候指定类型的一种特性 使用方法 泛型通过 <> 的形式进行表述，可以申明： 函数function returnItem(para: T): T { return para } 可以一次定义 [多个类型参数]，比如泛型T 和 泛型U ``` function swap(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]]; } swap([7, 'seven']); // ['seven', 7] * 接口 interface ReturnItemFn { (para: T): T } > 当我们想传入一个 number 作为参数的时候，可以这样申明 const returnItem: ReturnItemFn = para => para * 类 class Stack { private arr: T[] = [] public push(item: T) { this.arr.push(item) } public pop() { this.arr.pop() } } > 使用方式如下： const stack = new Stacn() ``` Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_node/":{"url":"chapter_node/","title":"Node 面试题","keywords":"","body":"typescript 面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_node/section_1.html":{"url":"chapter_node/section_1.html","title":"第 1 题：Nest.js 装饰器","keywords":"","body":"Nest.js 装饰器 内置装饰器 核心类@Catch：异常过滤器装饰器 @Controller：控制器装饰器 @UseFilters：异常过滤器装饰器 @Inject：显示依赖声明装饰器 @Injectable：被依赖装饰器 @Optional：可选装饰器 @SetMetadata：设置源数据装饰器 @UseGuards：守卫装饰器 @UseInterceptors：拦截器装饰器 @UsePipes：管道装饰器 Http类 @Header：响应头装饰器 @HttpCode：Http状态码装饰器 @Redirect：重定向装饰器 @Render：渲染装饰器 @RequestMapping：请求映射装饰器 @Request、@Response、@Next、@Ip、@Session、@Headers：路由参数装饰器 @Query、@Body、@Param、@HostParam：管道路由装饰器 @UploadFile：文件上传装饰器 @Sse：SSE装饰器 模块类 @Global: 全局装饰器 @Module：模块装饰器 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_node/section_2.html":{"url":"chapter_node/section_2.html","title":"第 2 题：Nest.js 与 Egg.js 等区别","keywords":"","body":"Nest.js 与 Egg.js 等区别 Nest.js 介绍 一个渐进式Node.js框架，用于构建高效，可靠和可扩展的服务器端应用程序，提供了一套完整的解决方案，包含了认证、数据库、路由、http状态码、安全、配置、请求等开箱即用的技术。 Koa.js 介绍 koa是一个拥有洋葱模型中间件的http处理库，一个请求，经过一系列的中间件，最后生成响应。 Koa的大致实现原理：context上下文的保存和传递，中间件的管理和next方法的实现。 区别 koa本身几乎不带任何其他的库，如果需要使用路由、错误处理、认证等功能需要自己安装并引入，什么都需要自己DIY。而使用nest.js时就不需要考虑这些问题了，依赖注入，pipe，guard，interceptor等机制，基本覆盖各种开发需要，开箱即用。 koa常常与express一起比较，都是偏底层的无态度的Web框架；而nest.js应该和egg.js，midway这种框架比较。egg.js源于阿里，它的企业级规范很多，但各方面能力极强，定位是框架的框架，其再上一层还有midwayjs，完全兼容ts，支持注解，一点都不输与Nest；此外国内做企业级NodeJS框架的越来多啦，比如刚出来的daruk等，用过Java Spring 框架和 Angular的同学会发现NEST借鉴了两者很多的特性。 egg.js是在koa的基础上做了一层很好的面向大型企业级应用的框架封装，现在也有了非常好的TS特性支持。egg.js更多的是按照洋葱模型的开发方式，和AOP编程还是有点区别的。而nest配合TYPEORM可以在node下拥有不输SPRING的面向切面编程的体验～ Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_construction/":{"url":"chapter_construction/","title":"前端工程化","keywords":"","body":"前端工程化 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 "},"chapter_construction/section_1.html":{"url":"chapter_construction/section_1.html","title":"第 1 题：前端工程内容","keywords":"","body":"第 1 题：前端工程化 前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的是为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间 工具 压缩工具：项目上线前，压缩代码。例如将文件内容中的注释、空格等删除，见换行变成一行，例如 minify 转换工具：例如将ES6、CSS3新特性进行转换，解决兼容性问题 Less、Sass等 CSS 的预编译语言进行编译处理 Vue、React等 JS 库进行转换 格式化格局：多人开发、统一开发规范，例如ESLint、Prettier等 自动化工具：自动化构建（npm script & script hooks等）、自动化部署（Git Hook、CI/CD等）、自动化测试（Jest、mocha等） 脚手架工具：专用脚手架、通用脚手架 通用脚手架：Yeoman、Plop 专用脚手架：vue-cli、create-react-app、angular-cli 模块化打包：Webpack、Rollup、Parcel 前端使用到大部分工具都是用 Node.js 进行开发的 工程化 !== 某个工具（例如webpack） 脚手架 理解 模块化 JS 模块化 在ES6之前，javascript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等,ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范,并且有静态加载的特性 用webpack+babel将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载； 用system+babel主要是分模块异步加载； 用浏览器加载 CSS 模块化 sass、less、stylus等预处理器实现了css的文件拆分,但没有解决css模块化的一个重要问题：选择器的全局污染问题。 资源的模块化 webpack的强大之处不仅仅在于它统一了js的各种模块系统，取代了browserify、requireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。 组件化 组件化实际是一种按照模板（html）+样式（css）+逻辑（js）三位一体的形式对面向对象的进一步抽象。目前市面上的组件化框架很多，主要有vue、react、angular 规范化 规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。 目录结构的制定 编码规范 前后端接口规范 文档规范 组件管理 git分支管理 commit描述规范 视觉图表规范 …… 自动化 前端工程化的很多脏活累活都应该交给自动化工具来完成。 图标合并 持续继承 自动化构建 自动化部署 自动化测试 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_construction/section_2.html":{"url":"chapter_construction/section_2.html","title":"第 2 题：从0-1搭建项目","keywords":"","body":"第 2 题：从0-1搭建项目 创建项目 安装UI组件 封装网络请求 路由配置 vuex配置 项目目录层级 项目环境配置 项目命名规范 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-19 "},"chapter_construction/section_3.html":{"url":"chapter_construction/section_3.html","title":"第 3 题：前端性能优化","keywords":"","body":"第 3 题：前端性能优化 浏览器 减少http请求 使用http2.0 设置浏览器缓存策略 白屏时间做加载动画 资源 静态资源cdn 静态资源单独域名 gzip 压缩 做服务端渲染（SSR） 将css放在头部，JavaScript放在底部 图片 字体图标代替图标 精灵图 图片懒加载 图片预加载 使用png格式的图片 小于10k的可以打包为 base64格式 代码 慎用全局变量 缓存全局变量 减少重绘回流 节流、防抖 少用闭包，减少内存泄漏 减少数据读取次数 项目 长列表优化 web worker 避免 iframe 嵌套网页 webpack 减少代码体积 按需加载 提取第三库代码 webpack dll 优化 vue 路由懒加载 v-for 路由 加 key 第三方插件按需加载 使用 computed 和 watch v-for 的同时时候 避免使用 v-if destroy 时销毁事件 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-20 "}}