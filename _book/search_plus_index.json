{"./":{"url":"./","title":"FE 汇总面试题","keywords":"","body":"Introduction 记录前端相关面试题。 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-11 "},"chapter_css/":{"url":"chapter_css/","title":"CSS 面试题","keywords":"","body":"chapter_css Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-11 "},"chapter_css/section_1.html":{"url":"chapter_css/section_1.html","title":"第 1 题：BFC","keywords":"","body":"第 1 题：BFC 及其应用 常见的定位方案 普通流 在普通流中，元素按照其 HTML 中的先后位置至上而下布局。在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位. 浮动 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或者右边偏移。 浮动定位 在绝对定位布局中，元素会整体脱离普通流 概念 BFC 即 块级格式化上下文。可以看做是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。 触发条件 body 根元素 浮动元素 float 除了 none 以外的值 绝对定位元素 position (absolute、fixed) display 为 inline-block、flex、table-cells overflow 除了 visible 以外的元素 特性及其应用 外边距折叠（margin折叠） 清除浮动 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 "},"chapter_css/section_2.html":{"url":"chapter_css/section_2.html","title":"第 2 题：div 水平垂直居中","keywords":"","body":"第 2 题：div 水平垂直居中 第一种 定宽高 定位 + 负 margin .element { position: absolute; left: 50%; top: 50%; margin-left: -250px; margin-top: -250px; width: 500px; height: 500px; background-color: red; } 定位 + margin: auto 原理 .element { position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; width: 500px; height: 500px; background-color: red; } 第二种 不定宽高 定位 + transform .element { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 500px; height: 500px; background-color: red; } flex .parent { display: flex; justify-content: center; align-items: center; width: 600px; height: 600px; background-color: greenyellow; } .element { width: 500px; height: 500px; background-color: red; } Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 "},"chapter_css/section_3.html":{"url":"chapter_css/section_3.html","title":"第 3 题：Flex","keywords":"","body":"Flex Flex 布局是什么 弹性布局，用来为盒装模型提供最大的灵活性 .box { display: flex; } 容器的属性 flex-direction 决定主轴的方向，即项目的排列方向 .box { flex-direction：row | row-reverse | column | column-reverse } row： 水平方向，起点在左端 row-reverse：水平方向，起点在右端 column：垂直方向，起点在上沿 column-reverse：垂直方向，起点在下沿 flex-wrap 若一条轴线排不下如何换行 .box { flex-wrap：nowrap | wrap | wrap-reverse } nowrap： 不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow 是 flex-direction 与 flex-wrap 的简写形式，默认为 row nowrap .box { flex-flow： || } justify-content 主轴上的对齐方式 .box { justify-content: flex-start | flex-end | center | space-between | space-around } flex-start：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等 align-items 交叉轴上如何对齐 .box { align-items: flex-start | flex-end | center | baseline | stretch } flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch：若项目未设置高度，则将占满整个容器的高度 align-content 多根轴线的对齐方式 .box { align-content：flex-start | flex-end | center | space-between | space-around | stretch } flext-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：没跟轴线两侧的间隔都相等 stretch：轴线占满整个交叉轴 项目的属性 order 定义项目的排序顺序，数值越小越靠前，默认为0 .item { order: } flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 .item { flex-grow： } 如果所有项目的 flex-grow 属性都为1，则他们将等分剩余空间。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 flex-shrink 定义项目的缩小比例，默认为，即如果空间不足，则项目将缩小 .item { flow-shrink: } 如果所有项目的 flex-shrink 属性都为1，则空间不足时，都将等比例缩小。如果一个项目的 flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 负值对该属性无效 flex-basis 定义了在分配多余的剩余空间之前，项目占据的主轴空间。默认为auto,即项目本来大小 .item { flex-basis: | auto } 它可以设为跟 width 和 height 属性一样的值，则项目将占据固定空间 flex 是 flex-grow、flex-shrink 和 flex-basis的简写，默认为 0 1 auto。 .item { flex: none | [ ? || ] } 该属相有两个快捷键：auto（1 1 auto）和 none （ 0 0 auto） flex: 1 （1 1 0%） align-self 允许单个项目有与其他项目不一样的对齐方式，可以覆盖 aligin-items 属性，默认为 auto,表示继承父元素的 align-items 属性。 .item { align-self：auto | flex-start | flex-end | center | baseline | stretch } Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_vue/":{"url":"chapter_vue/","title":"Vue 面试题","keywords":"","body":"vue 相关面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 "},"chapter_vue/section_1.html":{"url":"chapter_vue/section_1.html","title":"第 1 题：BFC","keywords":"","body":"第 1 题：vue-router 原理 前端路由 web 前端单页面中，路由描述的是 URL 与 UI 之间的映射关系，这种关系是单向的，即 URL 变化引起 UI 更新（无须刷新页面） hash 实现 hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，最重要的是改变 URL 中的 hash 部分不会引起页面刷新。 我们可以通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种： 通过浏览器前进后退改变 URL 通过标签改变 URL 通过 window.location 改变 URL history 实现 HTML5 标准的发布，history 的 api 增加了两个 API。pushState 和 replaceState。通过这两个 API 可以改变 URL 地址且不会发送请求。同时还有 popstate 事件。 用了这种实现方式，单页面路由的 url 就不会多出一个 #，变得更新加美观，但因为没有 # 号，所以当用户刷新页面之类的操作时候，浏览器还是会给服务器端发送请求。为了避免这种情况，所以这个实现需要服务器的支持，需要吧所有路由都重定向到根页面。 通过 pushState/replaceState或者标签改变 URL 不会触发页面刷新，也不会触发popstate方法。所以我们可以拦截 pushState/replaceState的调用和标签的点击事件来检测 URL 变化，从而触发 router-view 的视图更新 通过浏览器前进后退改变 url,或者通过 js 调用 history 的 back、go、forward方法，都会触发 popstate 事件，所以我们可以监听 popstate来触发 route-view 的视图更新 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 "},"chapter_typescript/":{"url":"chapter_typescript/","title":"Typescript 面试题","keywords":"","body":"typescript 面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_typescript/section_1.html":{"url":"chapter_typescript/section_1.html","title":"第 1 题：泛型的理解","keywords":"","body":"泛型 介绍 泛型是程序设计语言的一种分格或者范式 泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型在 typescript 中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候指定类型的一种特性 使用方法 泛型通过 <> 的形式进行表述，可以申明： 函数function returnItem(para: T): T { return para } 可以一次定义 [多个类型参数]，比如泛型T 和 泛型U ``` function swap(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]]; } swap([7, 'seven']); // ['seven', 7] * 接口 interface ReturnItemFn { (para: T): T } > 当我们想传入一个 number 作为参数的时候，可以这样申明 const returnItem: ReturnItemFn = para => para * 类 class Stack { private arr: T[] = [] public push(item: T) { this.arr.push(item) } public pop() { this.arr.pop() } } > 使用方式如下： const stack = new Stacn() ``` Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_node/":{"url":"chapter_node/","title":"Node 面试题","keywords":"","body":"typescript 面试题 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_node/section_1.html":{"url":"chapter_node/section_1.html","title":"第 1 题：Nest.js 装饰器","keywords":"","body":"Nest.js 装饰器 内置装饰器 核心类@Catch：异常过滤器装饰器 @Controller：控制器装饰器 @UseFilters：异常过滤器装饰器 @Inject：显示依赖声明装饰器 @Injectable：被依赖装饰器 @Optional：可选装饰器 @SetMetadata：设置源数据装饰器 @UseGuards：守卫装饰器 @UseInterceptors：拦截器装饰器 @UsePipes：管道装饰器 Http类 @Header：响应头装饰器 @HttpCode：Http状态码装饰器 @Redirect：重定向装饰器 @Render：渲染装饰器 @RequestMapping：请求映射装饰器 @Request、@Response、@Next、@Ip、@Session、@Headers：路由参数装饰器 @Query、@Body、@Param、@HostParam：管道路由装饰器 @UploadFile：文件上传装饰器 @Sse：SSE装饰器 模块类 @Global: 全局装饰器 @Module：模块装饰器 Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "},"chapter_node/section_2.html":{"url":"chapter_node/section_2.html","title":"第 2 题：Nest.js 与 Egg.js 等区别","keywords":"","body":"Nest.js 与 Egg.js 等区别 Nest.js 介绍 一个渐进式Node.js框架，用于构建高效，可靠和可扩展的服务器端应用程序，提供了一套完整的解决方案，包含了认证、数据库、路由、http状态码、安全、配置、请求等开箱即用的技术。 Koa.js 介绍 koa是一个拥有洋葱模型中间件的http处理库，一个请求，经过一系列的中间件，最后生成响应。 Koa的大致实现原理：context上下文的保存和传递，中间件的管理和next方法的实现。 区别 koa本身几乎不带任何其他的库，如果需要使用路由、错误处理、认证等功能需要自己安装并引入，什么都需要自己DIY。而使用nest.js时就不需要考虑这些问题了，依赖注入，pipe，guard，interceptor等机制，基本覆盖各种开发需要，开箱即用。 koa常常与express一起比较，都是偏底层的无态度的Web框架；而nest.js应该和egg.js，midway这种框架比较。egg.js源于阿里，它的企业级规范很多，但各方面能力极强，定位是框架的框架，其再上一层还有midwayjs，完全兼容ts，支持注解，一点都不输与Nest；此外国内做企业级NodeJS框架的越来多啦，比如刚出来的daruk等，用过Java Spring 框架和 Angular的同学会发现NEST借鉴了两者很多的特性。 egg.js是在koa的基础上做了一层很好的面向大型企业级应用的框架封装，现在也有了非常好的TS特性支持。egg.js更多的是按照洋葱模型的开发方式，和AOP编程还是有点区别的。而nest配合TYPEORM可以在node下拥有不输SPRING的面向切面编程的体验～ Copyright © 小阿圆 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-30 "}}