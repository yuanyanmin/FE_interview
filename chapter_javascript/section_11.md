# 第 11 题：http2 和 http1 不同

## HTTP 发展史

* Http/0.9 1991
* Http/1.0 1996
* Http/1.1 1999
* Http/2 2015
* Http/3 2018

## http/0.9

该协议诞生之初的作用是传输超文本内容HTML，并且只支持GET请求

**请求：** GET /index.html

**响应：** `<html><body>http 0.9</body></html>`

**流程：** 
  * 客户端与服务端建立 TCP 连接。
  * 客户端发送 GET 请求到服务端，请求 index.html 页面的数据。
  * 服务端发送完响应，关闭 TCP 连接。

**特点：** 简单，一个请求需要一个链接

**注意**

服务器发送完内容之后，就关闭TCP连接。这里需要注意一点，这里的TCP连接和http请求是不一样的。http请求和TCP连接不是一个概念。一个http请求通过TCP连接发送，而一个TCP连接里面可以发送很多个http请求（HTTP/0.9不能这么做，但是HTTP/1.1可以这么做，而且在HTTP/2这方面会更大程度地优化，来提高HTTP协议传输的效率以及服务器的性能）

## http/1.0

* 增加了 HEAD、POST 等新方法
* 增加了响应状态码，标记可能的错误原因
* 引入了协议版本号的概念
* 引入了 HTTP header 的概念，让 HTTP 处理请求和响应更加灵活
* 传输的数据不再局限于文本

**请求：** 第一行请求命令+版本信息，后面的多行为头信息

```
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

**响应：** 响应头信息 + 空行(\r\n) + 数据部分

```
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 2345
Expires: Thu, 05 Dec 2020 16:00:00 GMT
Last-Modified: Wed, 5 August 2020 15:55:28 GMT
Server: Apache 0.84

<html>
   <body>Hello World</body>
</html>
```

**缺点：**

主要的缺点还是跟HTTP/0.9一样，每一个TCP连接只能发送一个HTTP请求，服务器发送完响应，就关闭连接。如果后面需要请求新的数据，则需要再次建立TCP连接，但是TCP建立连接的三次握手成本比较高，并且TCP连接初始的时候发送数据的速度相对较慢，有一个慢启动和拥塞避免的阶段。极端情况，如果每次请求的数据很少，但是请求很频繁，这样每次请求很少的数据都需要建立连接然后断开

为了解决这个问题，在1.0版本使用了一个非标准的Connection头部字段。当客户端再请求头部信息里面带上Connection：keep-alive的时候，服务器在发送完响应数据之后，就不会断开TCP连接了，从而达到复用同一个TCP连接的目的。但是由于不是标准字段，不同的实现可能导致表现得不一致，因此不能从根本上解决这个问题

## http/1.1

随着互联网的快速发展，HTTP/1.0也无法满足用户需求了，最根本的问题就是链接问题， HTTP/1.0 每进行一次通信，都需要经历建立连接、传输数据和断开连接三个阶段。当一个页面引用了较多的外部文件时，这个建立连接和断开连接的过程就会增加大量网络开销。

**特点：**

* 长连接：引入了 TCP 连接复用，即一个 TCP 默认不关闭，可以被多个请求复用
* 并发请求：对一个域名的请求允许分配多个长连接（缓解了长连接中的「队头阻塞」问题）
* 引入管道机制，一个TCP连接，可以同时发送多个请求
* 增加了PUT、DELETE、OPTIONS、PATCH 等新方法
* 新增了一些换成的字段（If-Modified-Since、If-node-Match)
* 请求头引入了 range 字段，支持断点续传
* 允许响应数据分块(chunked)，利于传输大文件
* 强制要去 Host 头，让互联网托管成为可能

**HTTP 管道机制（pipelining)**

它指的是在一个TCP连接内，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能 够区分出每次请求的响应内容。

**局限性：**

* 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。
* pipeling 只部分解决了队头阻塞（ HOLB）。 HTTP 1.1 尝试使用 pipeling 来解决队头阻塞问题，即浏览器可以一次性发出多个请求（同个域名、同一条 TCP 链接）。 但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。
* 协议开销大，没有相应的压缩传输优化方案。 HTTP/1.1 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。


## http/2

2015 年正式发布的 HTTP/2 默认不再使用 ASCII 编码传输，而是改为二进制数据，来提升传输效率。
客户端在发送请求时会将每个请求的内容封装成不同的带有编号的二进制帧（Frame），然后将这些帧同时发送给服务端。服务端接收到数据之后，会将相同编号的帧合并为完整的请求信息。同样，服务端返回结果、客户端接收结果也遵循这个帧的拆分与组合的过程。
有了二进制分帧后，对于同一个域，客户端只需要与服务端建立一个连接即可完成通信需求，这种利用一个连接来发送多个请求的方式称为多路复用。每一条路都被称为一个 stream（流）。

**特点：**

* 二进制协议

* 多路复用

* 头部信息压缩

* 服务端主动推送

* 数据流


**缺点：**

TCP协议级别上仍然存在类似的队头问题


## http/3

HTTP3 背后的主要思想是放弃 TCP，转而使用基于 UDP 的 QUIC （快速UDP互联网连接）协议


## 总结

### HTTP/1.1与HTTP/2的区别

* 新的二进制格式（Binary Format），HTTP1.x解析是基于文本的，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

* 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

* header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

* 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。



[HTTP发展史，HTTP1.1与HTTP2.0的区别](https://juejin.cn/post/7079936383925616653)